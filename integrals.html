<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <label>
        x scale: <input type="range" min="10" max="300" onchange="setScale(this.value, 'x')" />
    </label>
    <label>
        y scale: <input type="range" min="10" max="300" onchange="setScale(this.value, 'y')" />
    </label>
    <canvas id="main_canvas"></canvas>

    <script type="text/javascript">

        var settings = {
            "delta": 0.06,

            // Size is set when canvas (re)sized
            "size": {},

            "lineWidth": 2,

            "scale": {
                "x": 70,
                "y": -140
            },

            "colours": {
                "upperSum": "#C22326",
                "lowerSum": "#027878",
            }
        }

        var f = function(x) {
            return x*x;
        }
        f.domain = [-2*Math.PI, 2*Math.PI];
        f.anchor = [0, 0];
        f.points = calculatePoints(f);
        var p = uniformPartition(f.domain, 40);

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function setScale(v, axis) {
            if (axis === "y") {
                v *= -1;
            }
            settings.scale[axis] = v;
            clearCanvas();
            drawSums(f, p);
            drawGraph(f);
        }

        function calculatePoints(f) {
            var points = [];
            for (var x=f.domain[0]; x<=f.domain[1]; x+=settings.delta) {
                points.push([x, f(x)]);
            }
            return points;
        }

        function uniformPartition(interval, n) {
            // Return a partition of the given interval with n sub-intervals of
            // equal width
            var p = [];
            var width = (interval[1] - interval[0]) / n;
            for (var x=interval[0]; x<=interval[1]; x+=width) {
                p.push(x);
            }
            return p;
        }

        function getCanvasCoord(f, t, axis) {
            var i = (axis === "x" ? 0 : 1);
            return 0.5*settings.size[axis] + settings.scale[axis]*(t - f.anchor[i]);
        }

        function drawGraph(f) {
            ctx.lineWidth = settings.lineWidth;
            ctx.beginPath();
            for (var i=0; i<f.points.length; i++) {
                var canvasX = getCanvasCoord(f, f.points[i][0], "x");
                var canvasY = getCanvasCoord(f, f.points[i][1], "y");

                ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();
        }

        function drawSums(f, p) {
            // Draw an upper/lower sum for the function f and partition p
            for (i=1; i<p.length; i++) {
                // // Endpoints of this sub-interval
                var start = p[i - 1];
                var end = p[i];

                // Get min/max value of f
                var minY = null;
                var maxY = null;

                for (var j=0; j<f.points.length; j++) {
                    var x = f.points[j][0];
                    var y = f.points[j][1];

                    if (start <= x && x <= end) {
                        // Set min/max if this is the first time;
                        if (minY === null) {
                            minY = y;
                            maxY = y;
                        }

                        if (y < minY) {
                            minY = y;
                        }
                        if (y > maxY) {
                            maxY = y;
                        }
                    }
                }

                // Colours and heights of rectangles
                var r = [];
                r.push([maxY, settings.colours.upperSum]);
                r.push([minY, settings.colours.lowerSum]);

                // If both max and min are positive then we want to draw upper
                // sums first, since they will fully cover lower sums otherwise.
                // However if max and min are both negative then lower sums
                // should be drawn first
                if (minY < 0 && maxY < 0) {
                    r.reverse();
                }

                for (var j=0; j<r.length; j++) {
                    ctx.fillStyle = r[j][1];
                    ctx.strokeRect(
                        getCanvasCoord(f, start, "x"), getCanvasCoord(f, 0, "y"),
                        settings.scale.x*(end - start), settings.scale.y*r[j][0]
                    );
                    ctx.fillRect(
                        getCanvasCoord(f, start, "x"), getCanvasCoord(f, 0, "y"),
                        settings.scale.x*(end - start), settings.scale.y*r[j][0]
                    );

                }
            }
        }

        function resizeCanvas() {
            // Make the canvas the full size of the screen
            // canvas.width = window.innerWidth;
            // canvas.height = window.innerHeight;

            settings.size.x = canvas.width;
            settings.size.y = canvas.height;

            drawSums(f, p);
            drawGraph(f);
        }

        var canvas = document.getElementById("main_canvas");
        var ctx = canvas.getContext("2d");

        canvas.width = 900;
        canvas.height = 600;

        resizeCanvas();
        // Resize canvas automatically
        window.addEventListener("resize", resizeCanvas);

        drawSums(f,p);
        drawGraph(f);


    </script>
</body>

</html>