<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <canvas id="main_canvas"></canvas>

    <script type="text/javascript">

        var settings = {
            "delta": 0.01,

            "grid": {
                "on": true,
                "ticks": [1, 5],
                "lineWidths": [0.5, 1],
                "colours": ["#777", "#555"]
            },

            "axis": {
                "on": true,
                "colour": "black",
                "lineWidth": 3
            },

            // Size is set when canvas (re)sized
            "size": {},

            "graph": {
                "lineWidth": 2,
                "colour": "black"
            },

            "scale": {
                "x": 70,
                "y": -70
                // y scale is always negative because we want up to be the
                // positive y direction, but for canvas coordinates it's the
                // other way around
            },

            "minScale": 10,
            "zoomFactor": 0.08, // The lower this number the slower zooming in is

            "sums": {
                "on": true,
                "opacity": 0.8,
                "borderColour": "black",
                "borderWidth": 3,
                "upperColour": "#C22326",
                "lowerColour": "#027878"
            },

            "border": {
                "on": true,
                "width": 5,
                "colour": "black"
            }
        }

        var f = function(x) {
            return Math.sin(x);
        }
        f.domain = [-18, 15];
        f.anchor = [0, 0];

        f.points = calculatePoints(f);
        var p = uniformPartition(f.domain, 50);

        function draw() {
            clearCanvas();

            if (settings.border.on) {
                ctx.strokeStyle = settings.border.colour;
                ctx.lineWidth = settings.border.width;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
            }

            if (settings.grid.on) {
                for (var i=0; i<settings.grid.ticks.length; i++) {
                    drawGrid(
                        settings.grid.ticks[i],
                        settings.grid.lineWidths[i],
                        settings.grid.colours[i]
                    );
                }
            }
            if (settings.sums.on) {
                drawSums(f, p);
            }
            drawGraph(f);

            if (settings.axis.on) {
                drawAxis(f);
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function getMouseCoords(e, canvas) {
            // Get the coordinates of the mouse event within the canvas
            return [e.pageX - canvas.offsetLeft, e.pageY - canvas.offsetTop];
        }

        function calculatePoints(f) {
            // Return an array of [x,f(x)] for x in domain of f at intervals of
            // settings.delta.
            var points = [];
            for (var x=f.domain[0]; x<=f.domain[1]; x+=settings.delta) {
                points.push([x, f(x)]);
            }
            return points;
        }

        function uniformPartition(interval, n) {
            // Return a partition of the given interval with n sub-intervals of
            // equal width
            var p = [];
            var width = (interval[1] - interval[0]) / n;
            for (var i=0; i<=n; i++) {
                p.push(interval[0] + i*width);
            }
            return p;
        }

        function getCanvasCoord(f, t, axis) {
            // Get canvas coordinate from real coordinate.
            // (If making changes here be sure to also update getRealCoord())
            var i = (axis === "x" ? 0 : 1);
            return 0.5*settings.size[axis] + settings.scale[axis]*(t - f.anchor[i]);
        }

        function getRealCoord(f, T, axis) {
            // Get the real coordinate from a canvas coordinate (inverse of
            // getCanvasCoord())
            var i = (axis === "x" ? 0 : 1);
            return f.anchor[i] + (T - 0.5*settings.size[axis]) / settings.scale[axis];
        }

        function drawGraph(f) {
            ctx.strokeStyle = settings.graph.colour;
            ctx.lineWidth = settings.graph.lineWidth;
            ctx.beginPath();
            for (var i=0; i<f.points.length; i++) {
                var canvasX = getCanvasCoord(f, f.points[i][0], "x");
                var canvasY = getCanvasCoord(f, f.points[i][1], "y");

                ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();
        }

        function round(x, n) {
            // Round x to the nearest n
            return Math.round(x / n) * n;
        }

        function drawGrid(frequency, thickness, colour) {
            var startX = round(getRealCoord(f, 0, "x"), frequency);
            var endY = round(getRealCoord(f, canvas.width, "x"), frequency);

            ctx.strokeStyle = colour;
            ctx.lineWidth = thickness;

            // Draw vertical lines
            for (var x=startX; x<=endY; x+=frequency) {
                ctx.beginPath();
                var canvasX = getCanvasCoord(f, x, "x");

                ctx.moveTo(canvasX, 0);
                ctx.lineTo(canvasX, canvas.height);
                ctx.stroke();
            }

            var startY = round(getRealCoord(f, canvas.height, "y"), frequency);
            var endY = round(getRealCoord(f, 0, "y"), frequency);

            // Draw horizontal lines
            for (var y=startY; y<=endY; y+=frequency) {
                ctx.beginPath();
                var canvasY = getCanvasCoord(f, y, "y");

                ctx.moveTo(0, canvasY);
                ctx.lineTo(canvas.width, canvasY);
                ctx.stroke();
            }
        }

        function drawAxis(f) {
            ctx.strokeStyle = settings.axis.colour;
            ctx.lineWidth = settings.axis.lineWidth;
            ctx.beginPath();
            var y = getCanvasCoord(f, 0, "y");
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        function drawSums(f, p) {
            // Draw and estimate an upper/lower sum for the function f and
            // partition p

            var upper = 0;
            var lower = 0;

            ctx.globalAlpha = settings.sums.opacity;

            for (i=1; i<p.length; i++) {
                // // Endpoints of this sub-interval
                var start = p[i - 1];
                var end = p[i];

                // Get min/max value of f
                var minY = null;
                var maxY = null;

                for (var j=0; j<f.points.length; j++) {
                    var x = f.points[j][0];
                    var y = f.points[j][1];

                    if (start <= x && x <= end) {
                        // Set min/max if this is the first time;
                        if (minY === null) {
                            minY = y;
                            maxY = y;
                        }

                        if (y < minY) {
                            minY = y;
                        }
                        if (y > maxY) {
                            maxY = y;
                        }
                    }
                }

                // Add to the estimates
                upper += maxY * (end - start);
                lower += minY * (end - start);

                // Colours and heights of rectangles
                var r = [];
                r.push([maxY, settings.sums.upperColour]);
                r.push([minY, settings.sums.lowerColour]);

                // If both max and min are positive then we want to draw upper
                // sums first, since they will fully cover lower sums otherwise.
                // However if max and min are both negative then lower sums
                // should be drawn first
                if (minY < 0 && maxY < 0) {
                    r.reverse();
                }

                for (var j=0; j<r.length; j++) {
                    ctx.strokeStyle = settings.sums.borderColour;
                    ctx.lineWidth = settings.sums.borderWidth;
                    ctx.fillStyle = r[j][1];
                    ctx.strokeRect(
                        getCanvasCoord(f, start, "x"), getCanvasCoord(f, 0, "y"),
                        settings.scale.x*(end - start), settings.scale.y*r[j][0]
                    );
                    ctx.fillRect(
                        getCanvasCoord(f, start, "x"), getCanvasCoord(f, 0, "y"),
                        settings.scale.x*(end - start), settings.scale.y*r[j][0]
                    );

                }
            }

            ctx.globalAlpha = 1;
        }

        function resizeCanvas() {
            // Make the canvas the full size of the screen
            // canvas.width = window.innerWidth;
            // canvas.height = window.innerHeight;

            settings.size.x = canvas.width;
            settings.size.y = canvas.height;

            draw();
        }

        var canvas = document.getElementById("main_canvas");
        var ctx = canvas.getContext("2d");

        canvas.width = 900;
        canvas.height = 600;

        // Pan when dragged
        var mouseDown = false;
        var dragPoint = null;
        canvas.addEventListener("mousedown", function(e) {
            dragPoint = getMouseCoords(e, canvas);
            mouseDown = true;
        });
        canvas.addEventListener("mousemove", function(e) {
            if (mouseDown) {
                // Adjust anchor to achieve panning
                var mouseCoords = getMouseCoords(e, canvas);
                f.anchor[0] += (dragPoint[0] - mouseCoords[0]) / settings.scale.x;
                f.anchor[1] += (dragPoint[1] - mouseCoords[1]) / settings.scale.y;

                draw();

                dragPoint = mouseCoords;
            }
        });
        canvas.addEventListener("mouseup", function(e) {
            mouseDown = false;
        });
        canvas.addEventListener("mouseleave", function(e) {
            // For some reason if you have mouse down over canvas and then move
            // mouse off screen/off the canvas, release the mouse, return to
            // canvas, mouseup event is not fired... So need to set mouseDown
            // to false here
            mouseDown = false;
        });

        // Zoom when scrolling
        canvas.addEventListener("mousewheel", function(e) {
            var mouseCoords = getMouseCoords(e, canvas);

            // Keep a copy of the original scale
            var origScale = [settings.scale.x, settings.scale.y]

            var d = settings.zoomFactor * e.wheelDelta;
            settings.scale.x += d;
            settings.scale.y -= d;

            // Make sure we're not zoomed too far out
            if (settings.scale.x <= settings.minScale) {
                settings.scale.x = settings.minScale;
            }
            // We have - here because y scale should always be negative
            if (-settings.scale.y <= settings.minScale) {
                settings.scale.y = -settings.minScale;
            }

            // Now need to adjust anchor so we have zoomed into the right part
            // of the graph
            f.anchor[0] -= (mouseCoords[0] - 0.5*settings.size.x)*((1 / settings.scale.x) - (1 / origScale[0]));
            f.anchor[1] -= (mouseCoords[1] - 0.5*settings.size.y)*((1 / settings.scale.y) - (1 / origScale[1]));

            draw();
        });

        resizeCanvas();
        // Resize canvas automatically
        window.addEventListener("resize", resizeCanvas);

        function animate() {
            var k = 1;
            setInterval(function() {
                p = uniformPartition(f.domain, k++);
                draw();
            }, 250)
        }

    </script>
</body>

</html>