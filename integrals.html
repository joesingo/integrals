<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <label>
        x scale: <input type="range" min="10" max="300" onchange="setScale(this.value, 'x')" />
    </label>
    <label>
        y scale: <input type="range" min="10" max="300" onchange="setScale(this.value, 'y')" />
    </label>
    <br />
    <label>
        anchor x: <input type="range" min="-10" max="10" onchange="setAnchor(this.value, 'x')" />
    </label>
    <label>
        anchor y: <input type="range" min="-10" max="10" onchange="setAnchor(this.value, 'y')" />
    </label>

    <canvas id="main_canvas"></canvas>

    <script type="text/javascript">

        var settings = {
            "delta": 0.01,

            // Size is set when canvas (re)sized
            "size": {},

            "lineWidth": 2,

            "scale": {
                "x": 70,
                "y": -70
                // y scale is always negative because we want up to be the
                // positive y direction, but for canvas coordinates it's the
                // other way around
            },

            "minScale": 10,
            "zoomFactor": 0.08, // The lower this number the slower zooming in is

            "colours": {
                "upperSum": "#C22326",
                "lowerSum": "#027878",
            }
        }

        var f = function(x) {
            return Math.sin(x);
        }
        f.domain = [-15, 15];
        f.anchor = [0, 0];
        f.points = calculatePoints(f);
        var p = uniformPartition(f.domain, 50);

        function draw() {
            clearCanvas();
            drawSums(f, p);
            drawGraph(f);
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function setScale(v, axis) {
            if (axis === "y") {
                v *= -1;
            }
            settings.scale[axis] = v;
            draw();
        }

        function setAnchor(v, axis) {
            var i = (axis === "x" ? 0 : 1);
            f.anchor[i] = parseFloat(v); // v comes from HTML input so is a string
            draw();
        }

        function getMouseCoords(e, canvas) {
            // Get the coordinates of the mouse event within the canvas
            return [e.pageX - canvas.offsetLeft, e.pageY - canvas.offsetTop];
        }

        function calculatePoints(f) {
            var points = [];
            for (var x=f.domain[0]; x<=f.domain[1]; x+=settings.delta) {
                points.push([x, f(x)]);
            }
            return points;
        }

        function uniformPartition(interval, n) {
            // Return a partition of the given interval with n sub-intervals of
            // equal width
            var p = [];
            var width = (interval[1] - interval[0]) / n;
            for (var x=interval[0]; x<=interval[1]; x+=width) {
                p.push(x);
            }
            return p;
        }

        function getCanvasCoord(f, t, axis) {
            var i = (axis === "x" ? 0 : 1);
            return 0.5*settings.size[axis] + settings.scale[axis]*(t - f.anchor[i]);
        }

        function drawGraph(f) {
            ctx.lineWidth = settings.lineWidth;
            ctx.beginPath();
            for (var i=0; i<f.points.length; i++) {
                var canvasX = getCanvasCoord(f, f.points[i][0], "x");
                var canvasY = getCanvasCoord(f, f.points[i][1], "y");

                ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();
        }

        function drawSums(f, p) {
            // Draw and estimate an upper/lower sum for the function f and
            // partition p

            var upper = 0;
            var lower = 0;

            for (i=1; i<p.length; i++) {
                // // Endpoints of this sub-interval
                var start = p[i - 1];
                var end = p[i];

                // Get min/max value of f
                var minY = null;
                var maxY = null;

                for (var j=0; j<f.points.length; j++) {
                    var x = f.points[j][0];
                    var y = f.points[j][1];

                    if (start <= x && x <= end) {
                        // Set min/max if this is the first time;
                        if (minY === null) {
                            minY = y;
                            maxY = y;
                        }

                        if (y < minY) {
                            minY = y;
                        }
                        if (y > maxY) {
                            maxY = y;
                        }
                    }
                }

                // Add to the estimates
                upper += maxY * (end - start);
                lower += minY * (end - start);

                // Colours and heights of rectangles
                var r = [];
                r.push([maxY, settings.colours.upperSum]);
                r.push([minY, settings.colours.lowerSum]);

                // If both max and min are positive then we want to draw upper
                // sums first, since they will fully cover lower sums otherwise.
                // However if max and min are both negative then lower sums
                // should be drawn first
                if (minY < 0 && maxY < 0) {
                    r.reverse();
                }

                for (var j=0; j<r.length; j++) {
                    ctx.fillStyle = r[j][1];
                    ctx.strokeRect(
                        getCanvasCoord(f, start, "x"), getCanvasCoord(f, 0, "y"),
                        settings.scale.x*(end - start), settings.scale.y*r[j][0]
                    );
                    ctx.fillRect(
                        getCanvasCoord(f, start, "x"), getCanvasCoord(f, 0, "y"),
                        settings.scale.x*(end - start), settings.scale.y*r[j][0]
                    );

                }
            }

            // console.log(lower + "," + upper);
        }

        function resizeCanvas() {
            // Make the canvas the full size of the screen
            // canvas.width = window.innerWidth;
            // canvas.height = window.innerHeight;

            settings.size.x = canvas.width;
            settings.size.y = canvas.height;

            draw();
        }

        var canvas = document.getElementById("main_canvas");
        var ctx = canvas.getContext("2d");

        canvas.width = 900;
        canvas.height = 600;

        // Pan when dragged
        var mouseDown = false;
        var dragPoint = null;
        canvas.addEventListener("mousedown", function(e) {
            dragPoint = getMouseCoords(e, canvas);
            mouseDown = true;
        });
        canvas.addEventListener("mousemove", function(e) {
            if (mouseDown) {
                // Adjust anchor to achieve panning
                var mouseCoords = getMouseCoords(e, canvas);
                f.anchor[0] += (dragPoint[0] - mouseCoords[0]) / settings.scale.x;
                f.anchor[1] += (dragPoint[1] - mouseCoords[1]) / settings.scale.y;

                draw();

                dragPoint = mouseCoords;
            }
        });
        canvas.addEventListener("mouseup", function(e) {
            mouseDown = false;
        });
        canvas.addEventListener("mouseleave", function(e) {
            // For some reason if you have mouse down over canvas and then move
            // mouse off screen/off the canvas, release the mouse, return to
            // canvas, mouseup event is not fired... So need to set mouseDown
            // to false here
            mouseDown = false;
        });

        // Zoom when scrolling
        canvas.addEventListener("mousewheel", function(e) {
            var mouseCoords = getMouseCoords(e, canvas);

            // Keep a copy of the original scale
            var origScale = [settings.scale.x, settings.scale.y]

            var d = settings.zoomFactor * e.wheelDelta;
            settings.scale.x += d;
            settings.scale.y -= d;

            // Make sure we're not zoomed too far out
            if (settings.scale.x <= settings.minScale) {
                settings.scale.x = settings.minScale;
            }
            // We have - here because y scale should always be negative
            if (-settings.scale.y <= settings.minScale) {
                settings.scale.y = -settings.minScale;
            }

            // Now need to adjust anchor so we have zoomed into the right part
            // of the graph
            f.anchor[0] -= (mouseCoords[0] - 0.5*settings.size.x)*((1 / settings.scale.x) - (1 / origScale[0]));
            f.anchor[1] -= (mouseCoords[1] - 0.5*settings.size.y)*((1 / settings.scale.y) - (1 / origScale[1]));

            draw();
        });

        resizeCanvas();
        // Resize canvas automatically
        window.addEventListener("resize", resizeCanvas);

        draw();

        function animate() {
            var k = 1;
            setInterval(function() {
                p = uniformPartition(f.domain, k++);
                draw();
            }, 250)
        }

    </script>
</body>

</html>